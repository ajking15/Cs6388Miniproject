/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Apr 14 2021 10:39:10 GMT-0500 (Central Daylight Time).
 */

define(["jointjs", "css!./styles/SimSMWidget.css"], function (joint) {
  "use strict";

  var WIDGET_CLASS = "sim-s-m";

  function SimSMWidget(logger, container) {
    this._logger = logger.fork("Widget");

    this._el = container;

    this.nodes = {};
    this._initialize();

    this._logger.debug("ctor finished");
  }

  SimSMWidget.prototype._initialize = function () {
    console.log(joint);
    var width = this._el.width(),
      height = this._el.height(),
      self = this;

    // set widget class
    this._el.addClass(WIDGET_CLASS);

    this._jointSM = new joint.dia.Graph();
    this._jointPaper = new joint.dia.Paper({
      el: this._el,
      width: width,
      height: height,
      model: this._jointSM,
      interactive: false,
    });

    // add event calls to elements
    this._jointPaper.on("element:pointerdblclick", function (elementView) {
      const currentElement = elementView.model;
      // console.log(currentElement);
      if (self._webgmeSM) {
        // console.log(self._webgmeSM.id2state[currentElement.id]);
        self._setCurrentState(self._webgmeSM.id2state[currentElement.id]);
      }
    });

    this._webgmeSM = null;
  };

  SimSMWidget.prototype.onWidgetContainerResize = function (width, height) {
    this._logger.debug("Widget is resizing...");
  };

  // State Machine manipulating functions called from the controller
  SimSMWidget.prototype.initMachine = function (machineDescriptor) {
    const self = this;
    console.log(machineDescriptor);

    self._webgmeSM = machineDescriptor;
    self._webgmeSM.current = self._webgmeSM.init;
    self._jointSM.clear();
    const sm = self._webgmeSM;
    sm.id2state = {}; // this dictionary will connect the on-screen id to the state id
    sm.path2id = {};
    // first add the states
    console.log(sm);
    Object.keys(sm.states).forEach((stateId) => {
      let vertex = null;
      if (sm.init === stateId) {
        vertex = new joint.shapes.standard.Circle({
          position: sm.states[stateId].position,
          size: { width: 20, height: 20 },
          attrs: {
            body: {
              fill: "#333333",
              cursor: "pointer",
            },
          },
        });
      } else if (sm.states[stateId].isEnd) {
        vertex = new joint.shapes.standard.Circle({
          position: sm.states[stateId].position,
          size: { width: 30, height: 30 },
          attrs: {
            body: {
              fill: "#999999",
              cursor: "pointer",
            },
          },
        });
      } else {
        vertex = new joint.shapes.standard.Circle({
          position: sm.states[stateId].position,
          size: { width: 60, height: 60 },
          attrs: {
            label: {
              text: sm.states[stateId].name,
              //event: 'element:label:pointerdown',
              fontWeight: "bold",
              //cursor: 'text',
              //style: {
              //    userSelect: 'text'
              //}
            },
            body: {
              strokeWidth: 3,
              cursor: "pointer",
            },
          },
        });
      }
      vertex.addTo(self._jointSM);
      sm.states[stateId].joint = vertex;
      sm.id2state[vertex.id] = stateId;
    });

    // then create the links
    Object.keys(sm).forEach((nodeType) => {
      let nt = sm[nodeType];
      //const state = sm.states[stateId];
      if(nodeType == 'Places'){
                Object.keys(nt).forEach(ntDetails => {
                    let nodeDetails = (nt[ntDetails]);
                    let tokens = nodeDetails.tokens;
                    let tokenSVGArray =[];

                    //This for loop builds the tok en portion of the Place SVG
                    for (i = 1; i <= tokens; i += 1) {
                        tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
                         }
                    let placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="none" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'

                    var vertex = new joint.shapes.basic.Image({
                        markup: placeSVG,      
                      });
                    
                    //Place the SVG in the same position as the META node
                    vertex.position(nodeDetails.x, nodeDetails.y)
            
                    //Add SVG to graph
                    vertex.addTo(self._jointSM);

                    sm.Places[ntDetails].joint = vertex;
                    sm.id2path[vertex.id] = ntDetails;
                    sm.path2id[ntDetails] = vertex.id;
                });
            }
            if(nodeType == 'Transitions'){
                Object.keys(nt).forEach(ntDetails => {
                    let nodeDetails = (nt[ntDetails]);

                    let vertex = new joint.shapes.standard.Rectangle();

                    vertex.position(nodeDetails.x, nodeDetails.y)
            
                    vertex.resize(30, 100);

                    vertex.attr({
                        body: {
                            fill: 'black'}});

                    vertex.addTo(self._jointSM);

                    sm.Transitions[ntDetails].joint = vertex;
                    sm.id2path[vertex.id] = ntDetails;
                    sm.path2id[ntDetails] = vertex.id;
                });
            }
            if(nodeType == 'Arcs'){
            Object.keys(nt).forEach(ntDetails => {
                let nodeDetails = (nt[ntDetails]);
                let src = nodeDetails.src;
                let dst = nodeDetails.dst;

                const link = new joint.shapes.standard.Link({
                    source: {id: sm.path2id[src]},
                    target: {id: sm.path2id[dst]},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    }
                });

                link.addTo(self._jointSM);
            });
        }
    });      

    //now refresh the visualization
    self._jointPaper.updateViews();
    self._decorateMachine();
  };

  SimSMWidget.prototype.destroyMachine = function () {};

/*
  SimSMWidget.prototype.fireEvent = function (event) {
    const self = this;
    const current = self._webgmeSM.states[self._webgmeSM.current];
    const link = current.jointNext[event];
    const linkView = link.findView(self._jointPaper);
    linkView.sendToken(
      joint.V("circle", { r: 10, fill: "black" }),
      { duration: 500 },
      function () {
        self._webgmeSM.current = current.next[event];
        self._decorateMachine();
      }
    );
  };
*/

  SimSMWidget.prototype.destroyMachine = function () {

    };
 SimSMWidget.prototype.fireEvent = function (event) {
   const self = this;
 };
  SimSMWidget.prototype.resetMachine = function () {
    this._webgmeSM.current = this._webgmeSM.init;
    Object.keys(this._webgmeSM.Places).forEach(place => {
      this._webgmeSM.Places[place].tokens = this._webgmeSM.Initial_Places[place].tokens;
    })
    this._decorateMachine();
  };

SimSMWidget.prototype._decorateMachine = function () {
    const sm = this._webgmeSM;
    Object.keys(sm.states).forEach((stateId) => {
      let nodeDetails = (this._webgmeSM.getAttribute('name'));
            let tokens = nodeDetails.tokens;
            let tokenSVGArray =[];
            let placeSVG = " ";
     for (i = 1; i <= tokens; i += 1) {
            tokenSVGArray.push(`<circle cx="50" cy="20" fill="black" stroke="white" r="10" transform="rotate(${i*60},50,50)"/>`)
            }
        
        placeSVG = '<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="50" stroke="black" stroke-width="2" fill="white" id="place"/>'+tokenSVGArray.join(' ')+'</svg>'
    });
    //sm.states[sm.current].joint.attr("body/stroke", "blue");
    //sm.setFireableEvents(Object.keys(sm.states[sm.current].next)); //.next
  };

  SimSMWidget.prototype._setCurrentState = function (newCurrent) {
    this._webgmeSM.current = newCurrent;
    this._decorateMachine();
  };

  /* * * * * * * * Visualizer event handlers * * * * * * * */

  /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
  SimSMWidget.prototype.destroy = function () {};

  SimSMWidget.prototype.onActivate = function () {
    this._logger.debug("SimSMWidget has been activated");
  };

  SimSMWidget.prototype.onDeactivate = function () {
    this._logger.debug("SimSMWidget has been deactivated");
  };

  return SimSMWidget;
});
